import './globals.css'
import { Inter } from 'next/font/google'
import Header from './components/Header'
import Footer from './components/Footer'
import { Providers } from './providers'
import { ThemeProvider } from './components/ThemeProvider'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'Our Family Website',
  description: 'A place to share and cherish our family memories',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={`${inter.className} bg-gray-50`}>
        <ThemeProvider>
          <div className="min-h-screen flex flex-col">
            <div className="flex-grow">
              <div className="absolute inset-0 bg-grid-pattern opacity-5 pointer-events-none" />
              <Providers>
                <Header />
                <main className="container mx-auto px-4 py-8 relative z-10">
                  {children}
                </main>
              </Providers>
            </div>
            <Footer />
          </div>
        </ThemeProvider>
      </body>
    </html>
  )
}



import Image from 'next/image'
import Link from 'next/link'
import { Carousel } from './components/Carousel'
import { PageHeader } from './components/PageHeader'

export default function Home() {
  // This would be fetched from your database in a real application
  const recentPhotos = [
    '/placeholder.svg?height=400&width=600',
    '/placeholder.svg?height=400&width=600',
    '/placeholder.svg?height=400&width=600',
  ]

  return (
    <div>
      <PageHeader 
        title="Welcome to Our Family Website" 
        description="A place to share and cherish our memories together"
      />
      <div className="mb-12">
        <Carousel images={recentPhotos} />
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-2xl font-semibold mb-4 text-primary">Recent Updates</h2>
          <ul className="space-y-2">
            <li className="flex items-center">
              <span className="w-2 h-2 bg-primary rounded-full mr-2"></span>
              New photos from the summer picnic
            </li>
            <li className="flex items-center">
              <span className="w-2 h-2 bg-primary rounded-full mr-2"></span>
              Upcoming family reunion details
            </li>
            <li className="flex items-center">
              <span className="w-2 h-2 bg-primary rounded-full mr-2"></span>
              Grandma's special recipe added to the cookbook
            </li>
          </ul>
        </div>
        <div className="bg-white rounded-lg shadow-md p-6">
          <h2 className="text-2xl font-semibold mb-4 text-primary">Quick Links</h2>
          <ul className="space-y-2">
            <li>
              <Link href="/photos" className="text-primary hover:underline">View Photo Gallery</Link>
            </li>
            <li>
              <Link href="/events" className="text-primary hover:underline">Check Upcoming Events</Link>
            </li>
            <li>
              <Link href="/stories" className="text-primary hover:underline">Read Family Stories</Link>
            </li>
          </ul>
        </div>
      </div>
    </div>
  )
}



'use client'

import { PasswordGate } from './components/PasswordGate'

export function Providers({ children }: { children: React.ReactNode }) {
  return <PasswordGate>{children}</PasswordGate>
}



'use client';

import { useState, useEffect } from 'react';
import { listFilesInFolder, uploadFileToDrive, deleteFile } from '../lib/googleDrive';
import { PageHeader } from '../components/PageHeader';

interface FamilyMember {
  id: string;
  metadata: {
    name: string;
    birthDate?: string;
    deathDate?: string;
    bio?: string;
    relationships?: {
      type: 'parent' | 'child' | 'spouse';
      memberId: string;
    }[];
    photoUrl?: string;
  };
}

export default function FamilyTree() {
  const [members, setMembers] = useState<FamilyMember[]>([]);
  const [loading, setLoading] = useState(true);
  const [newMember, setNewMember] = useState({
    name: '',
    birthDate: '',
    deathDate: '',
    bio: '',
  });

  const fetchMembers = async () => {
    try {
      const files = await listFilesInFolder(undefined);
      const familyMembers = files
        .filter(file => file.name.endsWith('.family'))
        .map(file => ({
          id: file.id,
          metadata: JSON.parse(file.description || '{}'),
        })) as FamilyMember[];
      setMembers(familyMembers);
    } catch (error) {
      console.error('Error fetching family members:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMembers();
  }, []);

  const handleAddMember = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      // Create a text file with .family extension to store member data
      const file = new File([''], `${newMember.name.toLowerCase().replace(/\s+/g, '-')}.family`, {
        type: 'text/plain',
      });

      await uploadFileToDrive(file, {
        ...newMember,
        relationships: [],
      });

      setNewMember({
        name: '',
        birthDate: '',
        deathDate: '',
        bio: '',
      });

      fetchMembers();
    } catch (error) {
      console.error('Error adding family member:', error);
      alert('Failed to add family member. Please try again.');
    }
  };

  const handleDeleteMember = async (memberId: string) => {
    if (!confirm('Are you sure you want to delete this family member?')) return;

    try {
      await deleteFile(memberId);
      fetchMembers();
    } catch (error) {
      console.error('Error deleting family member:', error);
      alert('Failed to delete family member. Please try again.');
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">Loading family tree...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <PageHeader
        title="Family Tree"
        description="Explore our family's roots and connections"
      />

      <div className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Add Family Member</h2>
        <form onSubmit={handleAddMember} className="max-w-md">
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-1">Name</label>
              <input
                type="text"
                value={newMember.name}
                onChange={(e) => setNewMember({ ...newMember, name: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Birth Date</label>
              <input
                type="date"
                value={newMember.birthDate}
                onChange={(e) => setNewMember({ ...newMember, birthDate: e.target.value })}
                className="w-full p-2 border rounded"
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Death Date</label>
              <input
                type="date"
                value={newMember.deathDate}
                onChange={(e) => setNewMember({ ...newMember, deathDate: e.target.value })}
                className="w-full p-2 border rounded"
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Bio</label>
              <textarea
                value={newMember.bio}
                onChange={(e) => setNewMember({ ...newMember, bio: e.target.value })}
                className="w-full p-2 border rounded"
                rows={4}
              />
            </div>
            <button
              type="submit"
              className="w-full bg-primary text-white p-2 rounded hover:bg-primary-dark"
            >
              Add Member
            </button>
          </div>
        </form>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {members.map((member) => (
          <div key={member.id} className="bg-white rounded-lg shadow-md p-6">
            <div className="flex justify-between items-start mb-4">
              <h3 className="text-xl font-semibold">{member.metadata.name}</h3>
              <button
                onClick={() => handleDeleteMember(member.id)}
                className="text-red-600 hover:text-red-800"
              >
                Delete
              </button>
            </div>
            {member.metadata.birthDate && (
              <p className="text-sm text-gray-600 mb-2">
                Born: {new Date(member.metadata.birthDate).toLocaleDateString()}
              </p>
            )}
            {member.metadata.deathDate && (
              <p className="text-sm text-gray-600 mb-2">
                Died: {new Date(member.metadata.deathDate).toLocaleDateString()}
              </p>
            )}
            {member.metadata.bio && (
              <p className="text-gray-700 mt-2">{member.metadata.bio}</p>
            )}
          </div>
        ))}
      </div>

      {members.length === 0 && (
        <div className="text-center text-gray-600 mt-8">
          No family members added yet. Start by adding your first family member!
        </div>
      )}
    </div>
  );
}


export interface FamilyMemberType {
  id: string
  name: string
  birthdate?: string
  bio?: string
  parentId?: string
  relationships?: { [key: string]: string }
  milestones?: { date: string, description: string }[]
}



'use client';

import { useState } from 'react';
import { listFilesInFolder } from '../lib/googleDrive';
import Image from 'next/image';
import Link from 'next/link';

interface SearchResult {
  id: string;
  name: string;
  metadata: {
    title?: string;
    content?: string;
    author?: string;
    date?: string;
    type: 'photo' | 'memory' | 'event' | 'profile';
    [key: string]: any;
  };
  webContentLink?: string;
}

export default function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<SearchResult[]>([]);
  const [loading, setLoading] = useState(false);

  const handleSearch = async () => {
    if (!query.trim()) return;

    setLoading(true);
    try {
      const files = await listFilesInFolder(undefined);
      
      // Filter and process results based on query
      const searchResults = files
        .filter(file => {
          const metadata = JSON.parse(file.description || '{}');
          const searchableText = [
            file.name,
            metadata.title,
            metadata.content,
            metadata.author,
            metadata.name,
            metadata.bio,
            (metadata.tags || []).join(' '),
          ].join(' ').toLowerCase();
          
          return searchableText.includes(query.toLowerCase());
        })
        .map(file => ({
          id: file.id,
          name: file.name,
          metadata: JSON.parse(file.description || '{}'),
          webContentLink: file.webContentLink,
        }));

      setResults(searchResults);
    } catch (error) {
      console.error('Error searching:', error);
      alert('Failed to search. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const renderResult = (result: SearchResult) => {
    const fileType = result.name.split('.').pop();
    const metadata = result.metadata;

    switch (fileType) {
      case 'memory':
        return (
          <div className="bg-white rounded-lg shadow-md p-6">
            <h3 className="text-xl font-semibold mb-2">{metadata.title}</h3>
            <p className="text-gray-700 mb-2">{metadata.content}</p>
            <p className="text-sm text-gray-600">
              Shared by {metadata.author} on {new Date(metadata.date!).toLocaleDateString()}
            </p>
          </div>
        );

      case 'profile':
        return (
          <Link href={`/profile/${result.name.replace('.profile', '')}`}>
            <div className="bg-white rounded-lg shadow-md p-6">
              <div className="flex items-center space-x-4">
                {metadata.avatar ? (
                  <Image
                    src={metadata.avatar}
                    alt={metadata.name}
                    width={64}
                    height={64}
                    className="rounded-full"
                  />
                ) : (
                  <div className="w-16 h-16 bg-gray-200 rounded-full flex items-center justify-center">
                    <span className="text-2xl text-gray-400">{metadata.name[0]}</span>
                  </div>
                )}
                <div>
                  <h3 className="text-xl font-semibold">{metadata.name}</h3>
                  <p className="text-gray-600">{metadata.bio}</p>
                </div>
              </div>
            </div>
          </Link>
        );

      case 'event':
        return (
          <div className="bg-white rounded-lg shadow-md p-6">
            <h3 className="text-xl font-semibold mb-2">{metadata.title}</h3>
            <p className="text-gray-700 mb-2">{metadata.description}</p>
            <p className="text-sm text-gray-600">
              {new Date(metadata.date!).toLocaleDateString()}
            </p>
          </div>
        );

      default:
        if (result.webContentLink && (result.name.endsWith('.jpg') || result.name.endsWith('.png'))) {
          return (
            <div className="bg-white rounded-lg shadow-md p-4">
              <div className="relative w-full h-48">
                <Image
                  src={result.webContentLink}
                  alt={metadata.title || result.name}
                  fill
                  className="rounded-lg object-cover"
                />
              </div>
              {metadata.title && (
                <div className="mt-2">
                  <h3 className="font-semibold">{metadata.title}</h3>
                  {metadata.date && (
                    <p className="text-sm text-gray-600">
                      {new Date(metadata.date).toLocaleDateString()}
                    </p>
                  )}
                </div>
              )}
            </div>
          );
        }
        return null;
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Search Family Content</h1>

      <div className="max-w-2xl mx-auto mb-8">
        <div className="flex gap-4">
          <input
            type="text"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
            placeholder="Search for photos, memories, events, or family members..."
            className="flex-1 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-primary"
          />
          <button
            onClick={handleSearch}
            disabled={loading}
            className="bg-primary text-white px-6 py-2 rounded hover:bg-primary-dark disabled:opacity-50"
          >
            {loading ? 'Searching...' : 'Search'}
          </button>
        </div>
      </div>

      {results.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {results.map((result) => (
            <div key={result.id}>
              {renderResult(result)}
            </div>
          ))}
        </div>
      ) : query && !loading ? (
        <div className="text-center text-gray-600">
          No results found for "{query}"
        </div>
      ) : null}
    </div>
  );
}


'use client'

import { useState } from 'react'
import { FamilyMemberType } from '../types/family'

interface AddFamilyMemberProps {
  onAdd: (newMember: Omit<FamilyMemberType, 'id'>) => void
  familyMembers: FamilyMemberType[]
}

export function AddFamilyMember({ onAdd, familyMembers }: AddFamilyMemberProps) {
  const [newMember, setNewMember] = useState<Omit<FamilyMemberType, 'id'>>({
    name: '',
    birthdate: '',
    bio: '',
    parentId: '',
    relationships: {},
    milestones: []
  })

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onAdd(newMember)
    setNewMember({
      name: '',
      birthdate: '',
      bio: '',
      parentId: '',
      relationships: {},
      milestones: []
    })
  }

  return (
    <form onSubmit={handleSubmit} className="bg-white rounded-lg shadow-md p-6">
      <h2 className="text-2xl font-bold mb-4 text-primary">Add Family Member</h2>
      <div className="space-y-4">
        <input
          type="text"
          value={newMember.name}
          onChange={(e) => setNewMember({ ...newMember, name: e.target.value })}
          placeholder="Name"
          className="w-full p-2 border rounded"
          required
        />
        <input
          type="date"
          value={newMember.birthdate}
          onChange={(e) => setNewMember({ ...newMember, birthdate: e.target.value })}
          className="w-full p-2 border rounded"
        />
        <textarea
          value={newMember.bio}
          onChange={(e) => setNewMember({ ...newMember, bio: e.target.value })}
          placeholder="Short bio"
          className="w-full p-2 border rounded"
          rows={3}
        />
        <select
          value={newMember.parentId}
          onChange={(e) => setNewMember({ ...newMember, parentId: e.target.value })}
          className="w-full p-2 border rounded"
        >
          <option value="">Select Parent (optional)</option>
          {familyMembers.map(member => (
            <option key={member.id} value={member.id}>{member.name}</option>
          ))}
        </select>
        <button
          type="submit"
          className="w-full bg-primary text-white p-2 rounded hover:bg-primary-dark transition-colors"
        >
          Add Family Member
        </button>
      </div>
    </form>
  )
}



interface PageHeaderProps {
  title: string
  description?: string
}

export function PageHeader({ title, description }: PageHeaderProps) {
  return (
    <div className="mb-8 text-center">
      <h1 className="text-4xl font-bold mb-2 text-primary">{title}</h1>
      {description && <p className="text-gray-600">{description}</p>}
    </div>
  )
}



'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { SearchIcon } from 'lucide-react'

export function Search() {
  const [query, setQuery] = useState('')
  const router = useRouter()

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault()
    if (query.trim()) {
      router.push(`/search?q=${encodeURIComponent(query)}`)
    }
  }

  return (
    <form onSubmit={handleSearch} className="relative">
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
        className="w-full p-2 pl-10 border rounded focus:outline-none focus:ring-2 focus:ring-primary"
      />
      <SearchIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={20} />
    </form>
  )
}



'use client'

import { useState } from 'react'
import { useAuth } from '../hooks/useAuth'

export function PasswordGate({ children }: { children: React.ReactNode }) {
  const [password, setPassword] = useState('')
  const { isAuthenticated, login, error } = useAuth()

  if (isAuthenticated) {
    return <>{children}</>
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-96">
        <h2 className="text-2xl font-bold mb-4">Family Website</h2>
        <p className="mb-4">Please enter the password to access the site:</p>
        <input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          className="w-full p-2 border rounded mb-4"
          placeholder="Enter password"
        />
        <button
          onClick={() => login(password)}
          className="w-full bg-blue-500 text-white p-2 rounded hover:bg-blue-600"
        >
          Enter
        </button>
        {error && <p className="text-red-500 mt-2">{error}</p>}
      </div>
    </div>
  )
}



export default function Footer() {
  return (
    <footer className="bg-white border-t">
      <div className="container mx-auto px-4 py-6 text-center text-gray-600">
        <p>&copy; {new Date().getFullYear()} Our Family Website. All rights reserved.</p>
      </div>
    </footer>
  )
}



'use client'

import { useState } from 'react'
import { FamilyMemberType } from '../types/family'
import { Edit2, Trash2, Plus, X } from 'lucide-react'

interface FamilyMemberProps {
  member: FamilyMemberType
  onUpdate: (updatedMember: Partial<FamilyMemberType>) => void
  onDelete: () => void
}

export function FamilyMember({ member, onUpdate, onDelete }: FamilyMemberProps) {
  const [isEditing, setIsEditing] = useState(false)
  const [editedMember, setEditedMember] = useState(member)
  const [newMilestone, setNewMilestone] = useState({ date: '', description: '' })

  const handleSave = () => {
    onUpdate(editedMember)
    setIsEditing(false)
  }

  const handleAddMilestone = () => {
    if (newMilestone.date && newMilestone.description) {
      setEditedMember(prev => ({
        ...prev,
        milestones: [...(prev.milestones || []), newMilestone]
      }))
      setNewMilestone({ date: '', description: '' })
    }
  }

  const handleRemoveMilestone = (index: number) => {
    setEditedMember(prev => ({
      ...prev,
      milestones: prev.milestones?.filter((_, i) => i !== index)
    }))
  }

  if (isEditing) {
    return (
      <div className="bg-white rounded-lg shadow-md p-4">
        <input
          type="text"
          value={editedMember.name}
          onChange={(e) => setEditedMember({ ...editedMember, name: e.target.value })}
          className="w-full p-2 border rounded mb-2"
        />
        <input
          type="date"
          value={editedMember.birthdate}
          onChange={(e) => setEditedMember({ ...editedMember, birthdate: e.target.value })}
          className="w-full p-2 border rounded mb-2"
        />
        <textarea
          value={editedMember.bio}
          onChange={(e) => setEditedMember({ ...editedMember, bio: e.target.value })}
          className="w-full p-2 border rounded mb-2"
          rows={3}
        />
        <h4 className="font-semibold mt-4 mb-2">Milestones</h4>
        {editedMember.milestones?.map((milestone, index) => (
          <div key={index} className="flex items-center mb-2">
            <input
              type="date"
              value={milestone.date}
              onChange={(e) => {
                const newMilestones = [...(editedMember.milestones || [])]
                newMilestones[index] = { ...milestone, date: e.target.value }
                setEditedMember({ ...editedMember, milestones: newMilestones })
              }}
              className="p-2 border rounded mr-2"
            />
            <input
              type="text"
              value={milestone.description}
              onChange={(e) => {
                const newMilestones = [...(editedMember.milestones || [])]
                newMilestones[index] = { ...milestone, description: e.target.value }
                setEditedMember({ ...editedMember, milestones: newMilestones })
              }}
              className="flex-grow p-2 border rounded mr-2"
            />
            <button onClick={() => handleRemoveMilestone(index)} className="text-red-500">
              <X size={20} />
            </button>
          </div>
        ))}
        <div className="flex items-center mt-2">
          <input
            type="date"
            value={newMilestone.date}
            onChange={(e) => setNewMilestone({ ...newMilestone, date: e.target.value })}
            className="p-2 border rounded mr-2"
          />
          <input
            type="text"
            value={newMilestone.description}
            onChange={(e) => setNewMilestone({ ...newMilestone, description: e.target.value })}
            placeholder="New milestone"
            className="flex-grow p-2 border rounded mr-2"
          />
          <button onClick={handleAddMilestone} className="text-green-500">
            <Plus size={20} />
          </button>
        </div>
        <div className="mt-4 flex justify-end space-x-2">
          <button onClick={() => setIsEditing(false)} className="px-4 py-2 bg-gray-200 rounded">Cancel</button>
          <button onClick={handleSave} className="px-4 py-2 bg-primary text-white rounded">Save</button>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow-md p-4">
      <div className="flex justify-between items-start">
        <div>
          <h3 className="text-lg font-semibold">{member.name}</h3>
          {member.birthdate && <p className="text-sm text-gray-600">Born: {member.birthdate}</p>}
          {member.bio && <p className="text-sm mt-2">{member.bio}</p>}
        </div>
        <div className="flex space-x-2">
          <button onClick={() => setIsEditing(true)} className="text-blue-500">
            <Edit2 size={20} />
          </button>
          <button onClick={onDelete} className="text-red-500">
            <Trash2 size={20} />
          </button>
        </div>
      </div>
      {member.milestones && member.milestones.length > 0 && (
        <div className="mt-4">
          <h4 className="font-semibold mb-2">Milestones</h4>
          <ul className="list-disc list-inside">
            {member.milestones.map((milestone, index) => (
              <li key={index} className="text-sm">
                {milestone.date}: {milestone.description}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  )
}



'use client'

import { useState, useCallback } from 'react'
import ReactCrop, { Crop } from 'react-image-crop'
import 'react-image-crop/dist/ReactCrop.css'

interface ImageEditorProps {
  src: string
  onSave: (croppedImageUrl: string) => void
}

export function ImageEditor({ src, onSave }: ImageEditorProps) {
  const [crop, setCrop] = useState<Crop>()
  const [imageRef, setImageRef] = useState<HTMLImageElement | null>(null)

  const onImageLoaded = useCallback((img: HTMLImageElement) => {
    setImageRef(img)
  }, [])

  const handleSave = useCallback(() => {
    if (imageRef && crop) {
      const canvas = document.createElement('canvas')
      const scaleX = imageRef.naturalWidth / imageRef.width
      const scaleY = imageRef.naturalHeight / imageRef.height
      canvas.width = crop.width
      canvas.height = crop.height
      const ctx = canvas.getContext('2d')

      if (ctx) {
        ctx.drawImage(
          imageRef,
          crop.x * scaleX,
          crop.y * scaleY,
          crop.width * scaleX,
          crop.height * scaleY,
          0,
          0,
          crop.width,
          crop.height
        )

        canvas.toBlob((blob) => {
          if (blob) {
            const croppedImageUrl = URL.createObjectURL(blob)
            onSave(croppedImageUrl)
          }
        })
      }
    }
  }, [imageRef, crop, onSave])

  return (
    <div>
      <ReactCrop crop={crop} onChange={c => setCrop(c)}>
        <img src={src} onLoad={e => onImageLoaded(e.currentTarget)} />
      </ReactCrop>
      <button onClick={handleSave} className="mt-4 bg-primary text-white p-2 rounded">
        Save Cropped Image
      </button>
    </div>
  )
}



'use client';

import { useState } from 'react';
import { uploadFileToDrive } from '../lib/googleDrive';

interface PhotoUploadProps {
  onUploadComplete?: (fileData: any) => void;
}

export default function PhotoUpload({ onUploadComplete }: PhotoUploadProps) {
  const [uploading, setUploading] = useState(false);
  const [metadata, setMetadata] = useState({
    title: '',
    description: '',
    date: '',
    tags: [] as string[],
    location: ''
  });

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    setUploading(true);
    try {
      const uploadPromises = Array.from(files).map(async (file) => {
        const result = await uploadFileToDrive(file, {
          ...metadata,
          date: metadata.date || new Date().toISOString()
        });
        return result;
      });

      const results = await Promise.all(uploadPromises);
      onUploadComplete?.(results);
    } catch (error) {
      console.error('Error uploading files:', error);
      alert('Error uploading files. Please try again.');
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="w-full max-w-md mx-auto p-4">
      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Title</label>
        <input
          type="text"
          value={metadata.title}
          onChange={(e) => setMetadata({ ...metadata, title: e.target.value })}
          className="w-full p-2 border rounded"
        />
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Description</label>
        <textarea
          value={metadata.description}
          onChange={(e) => setMetadata({ ...metadata, description: e.target.value })}
          className="w-full p-2 border rounded"
        />
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Date</label>
        <input
          type="date"
          value={metadata.date}
          onChange={(e) => setMetadata({ ...metadata, date: e.target.value })}
          className="w-full p-2 border rounded"
        />
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Tags (comma-separated)</label>
        <input
          type="text"
          value={metadata.tags.join(', ')}
          onChange={(e) => setMetadata({ ...metadata, tags: e.target.value.split(',').map(tag => tag.trim()) })}
          className="w-full p-2 border rounded"
        />
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Location</label>
        <input
          type="text"
          value={metadata.location}
          onChange={(e) => setMetadata({ ...metadata, location: e.target.value })}
          className="w-full p-2 border rounded"
        />
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium mb-1">Choose Files</label>
        <input
          type="file"
          onChange={handleFileChange}
          multiple
          accept="image/*,video/*"
          className="w-full p-2 border rounded"
          disabled={uploading}
        />
      </div>

      {uploading && (
        <div className="text-center text-sm text-gray-600">
          Uploading files...
        </div>
      )}
    </div>
  );
}


'use client'

import { createContext, useContext, useEffect, useState } from 'react'
import { listFilesInFolder, uploadFileToDrive, updateFileMetadata } from '../lib/googleDrive'

interface ThemeContextType {
  theme: string
  setTheme: (theme: string) => void
}

const ThemeContext = createContext<ThemeContextType>({
  theme: 'light',
  setTheme: () => {},
})

export function useTheme() {
  return useContext(ThemeContext)
}

interface ThemeFile {
  id: string
  metadata: {
    theme: string
  }
}

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setThemeState] = useState('light')
  const [themeFileId, setThemeFileId] = useState<string | null>(null)

  useEffect(() => {
    const fetchTheme = async () => {
      try {
        const files = await listFilesInFolder(undefined)
        const themeFile = files.find(file => file.name === 'theme.config') as ThemeFile | undefined

        if (themeFile) {
          setThemeFileId(themeFile.id)
          setThemeState(themeFile.metadata.theme || 'light')
        } else {
          // Create theme file if it doesn't exist
          const file = new File([''], 'theme.config', { type: 'text/plain' })
          const result = await uploadFileToDrive(file, { theme: 'light' })
          setThemeFileId(result.id)
        }
      } catch (error) {
        console.error('Error fetching theme:', error)
      }
    }

    fetchTheme()
  }, [])

  const setTheme = async (newTheme: string) => {
    try {
      if (themeFileId) {
        await updateFileMetadata(themeFileId, { theme: newTheme })
      } else {
        const file = new File([''], 'theme.config', { type: 'text/plain' })
        const result = await uploadFileToDrive(file, { theme: newTheme })
        setThemeFileId(result.id)
      }
      setThemeState(newTheme)
    } catch (error) {
      console.error('Error updating theme:', error)
    }
  }

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <div className={theme}>
        {children}
      </div>
    </ThemeContext.Provider>
  )
}


'use client'

import { useState } from 'react'
import Image from 'next/image'
import { ChevronLeft, ChevronRight, X } from 'lucide-react'

interface SlideshowProps {
  images: { id: string; url: string; caption: string }[]
  onClose: () => void
}

export function Slideshow({ images, onClose }: SlideshowProps) {
  const [currentIndex, setCurrentIndex] = useState(0)

  const nextSlide = () => {
    setCurrentIndex((prevIndex) =>
      prevIndex === images.length - 1 ? 0 : prevIndex + 1
    )
  }

  const prevSlide = () => {
    setCurrentIndex((prevIndex) =>
      prevIndex === 0 ? images.length - 1 : prevIndex - 1
    )
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
      <button
        onClick={onClose}
        className="absolute top-4 right-4 text-white"
      >
        <X size={24} />
      </button>
      <button
        onClick={prevSlide}
        className="absolute left-4 text-white"
      >
        <ChevronLeft size={24} />
      </button>
      <button
        onClick={nextSlide}
        className="absolute right-4 text-white"
      >
        <ChevronRight size={24} />
      </button>
      <div className="relative">
        <Image
          src={images[currentIndex].url}
          alt={images[currentIndex].caption}
          width={800}
          height={600}
          className="max-w-full max-h-[80vh] object-contain"
        />
        <p className="absolute bottom-4 left-0 right-0 text-center text-white bg-black bg-opacity-50 p-2">
          {images[currentIndex].caption}
        </p>
      </div>
    </div>
  )
}



'use client'

import Link from 'next/link'
import { useState } from 'react'
import { usePathname } from 'next/navigation'
import { Menu, X } from 'lucide-react'

const navItems = [
  { name: 'Home', path: '/' },
  { name: 'Photos', path: '/photos' },
  { name: 'Videos', path: '/videos' },
  { name: 'Stories', path: '/stories' },
  { name: 'Family Tree', path: '/family-tree' },
  { name: 'Events', path: '/events' },
]

export default function Header() {
  const [isOpen, setIsOpen] = useState(false)
  const pathname = usePathname()

  return (
    <header className="bg-white shadow-md">
      <div className="container mx-auto px-4">
        <nav className="flex items-center justify-between h-16">
          <Link href="/" className="text-2xl font-bold text-primary">
            Our Family
          </Link>
          <div className="hidden md:flex space-x-4">
            {navItems.map((item) => (
              <Link
                key={item.name}
                href={item.path}
                className={`text-gray-600 hover:text-primary transition-colors ${
                  pathname === item.path ? 'font-semibold text-primary' : ''
                }`}
              >
                {item.name}
              </Link>
            ))}
          </div>
          <button
            className="md:hidden focus:outline-none"
            onClick={() => setIsOpen(!isOpen)}
          >
            {isOpen ? <X size={24} /> : <Menu size={24} />}
          </button>
        </nav>
      </div>
      {isOpen && (
        <div className="md:hidden bg-white border-t">
          {navItems.map((item) => (
            <Link
              key={item.name}
              href={item.path}
              className={`block px-4 py-2 text-gray-600 hover:bg-gray-100 ${
                pathname === item.path ? 'font-semibold text-primary' : ''
              }`}
              onClick={() => setIsOpen(false)}
            >
              {item.name}
            </Link>
          ))}
        </div>
      )}
    </header>
  )
}



'use client';

import { useState, useEffect } from 'react';
import { listFilesInFolder, uploadFileToDrive, deleteFile } from '../lib/googleDrive';

interface Memory {
  id: string;
  metadata: {
    title: string;
    content: string;
    author: string;
    date: string;
    tags?: string[];
  };
}

export default function MemoryWall() {
  const [memories, setMemories] = useState<Memory[]>([]);
  const [loading, setLoading] = useState(true);
  const [newMemory, setNewMemory] = useState({
    title: '',
    content: '',
    author: '',
    date: new Date().toISOString().split('T')[0],
    tags: [] as string[],
  });

  const fetchMemories = async () => {
    try {
      const files = await listFilesInFolder(undefined);
      const memoryFiles = files
        .filter(file => file.name.endsWith('.memory'))
        .map(file => ({
          id: file.id,
          metadata: JSON.parse(file.description || '{}'),
        }))
        .sort((a, b) => new Date(b.metadata.date).getTime() - new Date(a.metadata.date).getTime()) as Memory[];
      setMemories(memoryFiles);
    } catch (error) {
      console.error('Error fetching memories:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMemories();
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const file = new File([''], `${newMemory.title.toLowerCase().replace(/\s+/g, '-')}.memory`, {
        type: 'text/plain',
      });

      await uploadFileToDrive(file, {
        ...newMemory,
        date: newMemory.date || new Date().toISOString().split('T')[0],
      });

      setNewMemory({
        title: '',
        content: '',
        author: '',
        date: new Date().toISOString().split('T')[0],
        tags: [],
      });

      fetchMemories();
    } catch (error) {
      console.error('Error adding memory:', error);
      alert('Failed to add memory. Please try again.');
    }
  };

  const handleDelete = async (memoryId: string) => {
    if (!confirm('Are you sure you want to delete this memory?')) return;

    try {
      await deleteFile(memoryId);
      fetchMemories();
    } catch (error) {
      console.error('Error deleting memory:', error);
      alert('Failed to delete memory. Please try again.');
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">Loading memories...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h2 className="text-3xl font-bold mb-8">Memory Wall</h2>

      <div className="mb-8">
        <h3 className="text-2xl font-semibold mb-4">Share a Memory</h3>
        <form onSubmit={handleSubmit} className="max-w-md">
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-1">Title</label>
              <input
                type="text"
                value={newMemory.title}
                onChange={(e) => setNewMemory({ ...newMemory, title: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Content</label>
              <textarea
                value={newMemory.content}
                onChange={(e) => setNewMemory({ ...newMemory, content: e.target.value })}
                className="w-full p-2 border rounded"
                rows={4}
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Author</label>
              <input
                type="text"
                value={newMemory.author}
                onChange={(e) => setNewMemory({ ...newMemory, author: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Date</label>
              <input
                type="date"
                value={newMemory.date}
                onChange={(e) => setNewMemory({ ...newMemory, date: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Tags (comma-separated)</label>
              <input
                type="text"
                value={newMemory.tags.join(', ')}
                onChange={(e) => setNewMemory({
                  ...newMemory,
                  tags: e.target.value.split(',').map(tag => tag.trim()).filter(Boolean),
                })}
                className="w-full p-2 border rounded"
              />
            </div>
            <button
              type="submit"
              className="w-full bg-primary text-white p-2 rounded hover:bg-primary-dark"
            >
              Share Memory
            </button>
          </div>
        </form>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {memories.map((memory) => (
          <div key={memory.id} className="bg-white rounded-lg shadow-md p-6">
            <div className="flex justify-between items-start mb-4">
              <h3 className="text-xl font-semibold">{memory.metadata.title}</h3>
              <button
                onClick={() => handleDelete(memory.id)}
                className="text-red-600 hover:text-red-800"
              >
                Delete
              </button>
            </div>
            <p className="text-gray-700 mb-4">{memory.metadata.content}</p>
            <p className="text-sm text-gray-600">
              Shared by {memory.metadata.author} on{' '}
              {new Date(memory.metadata.date).toLocaleDateString()}
            </p>
            {memory.metadata.tags && memory.metadata.tags.length > 0 && (
              <div className="flex flex-wrap gap-2 mt-4">
                {memory.metadata.tags.map((tag, index) => (
                  <span
                    key={index}
                    className="bg-gray-100 text-gray-600 px-2 py-1 rounded-full text-sm"
                  >
                    {tag}
                  </span>
                ))}
              </div>
            )}
          </div>
        ))}
      </div>

      {memories.length === 0 && (
        <div className="text-center text-gray-600 mt-8">
          No memories shared yet. Be the first to share a memory!
        </div>
      )}
    </div>
  );
}


'use client'

import { useState } from 'react'
import Image from 'next/image'
import { ChevronLeft, ChevronRight } from 'lucide-react'

interface CarouselProps {
  images: string[]
}

export function Carousel({ images }: CarouselProps) {
  const [currentIndex, setCurrentIndex] = useState(0)

  const nextSlide = () => {
    setCurrentIndex((prevIndex) =>
      prevIndex === images.length - 1 ? 0 : prevIndex + 1
    )
  }

  const prevSlide = () => {
    setCurrentIndex((prevIndex) =>
      prevIndex === 0 ? images.length - 1 : prevIndex - 1
    )
  }

  return (
    <div className="relative overflow-hidden rounded-lg shadow-lg">
      <div
        className="flex transition-transform duration-500 ease-in-out"
        style={{ transform: `translateX(-${currentIndex * 100}%)` }}
      >
        {images.map((src, index) => (
          <div key={index} className="w-full flex-shrink-0">
            <Image
              src={src}
              alt={`Slide ${index + 1}`}
              width={600}
              height={400}
              className="w-full h-auto"
            />
          </div>
        ))}
      </div>
      <button
        className="absolute top-1/2 left-4 transform -translate-y-1/2 bg-black bg-opacity-50 text-white p-2 rounded-full hover:bg-opacity-75 transition-opacity"
        onClick={prevSlide}
      >
        <ChevronLeft size={24} />
      </button>
      <button
        className="absolute top-1/2 right-4 transform -translate-y-1/2 bg-black bg-opacity-50 text-white p-2 rounded-full hover:bg-opacity-75 transition-opacity"
        onClick={nextSlide}
      >
        <ChevronRight size={24} />
      </button>
      <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex space-x-2">
        {images.map((_, index) => (
          <button
            key={index}
            className={`w-2 h-2 rounded-full ${
              index === currentIndex ? 'bg-white' : 'bg-gray-400'
            }`}
            onClick={() => setCurrentIndex(index)}
          />
        ))}
      </div>
    </div>
  )
}



'use client';

import { useState, useEffect } from 'react';
import { listFilesInFolder, uploadFileToDrive, updateFileMetadata, deleteFile } from '../lib/googleDrive';
import Image from 'next/image';

interface Story {
  id: string;
  metadata: {
    title: string;
    content: string;
    author: string;
    date: string;
    images: string[];
    tags: string[];
  };
}

export default function MemoryWall() {
  const [stories, setStories] = useState<Story[]>([]);
  const [loading, setLoading] = useState(true);
  const [showForm, setShowForm] = useState(false);
  const [newStory, setNewStory] = useState({
    title: '',
    content: '',
    author: '',
    date: new Date().toISOString().split('T')[0],
    tags: [] as string[],
  });
  const [selectedImages, setSelectedImages] = useState<File[]>([]);

  useEffect(() => {
    fetchStories();
  }, []);

  const fetchStories = async () => {
    try {
      const files = await listFilesInFolder(undefined);
      const storyFiles = files
        .filter(file => file.name.endsWith('.story'))
        .map(file => ({
          id: file.id,
          metadata: JSON.parse(file.description || '{}'),
        }))
        .sort((a, b) => new Date(b.metadata.date).getTime() - new Date(a.metadata.date).getTime()) as Story[];
      
      setStories(storyFiles);
    } catch (error) {
      console.error('Error fetching stories:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);

    try {
      // First, upload all images
      const uploadedImages = await Promise.all(
        selectedImages.map(async (image) => {
          const result = await uploadFileToDrive(image, {
            type: 'story-image',
            storyTitle: newStory.title,
          });
          return result.webContentLink;
        })
      );

      // Create the story file
      const file = new File([''], `${newStory.title.toLowerCase().replace(/\s+/g, '-')}.story`, {
        type: 'text/plain',
      });

      await uploadFileToDrive(file, {
        ...newStory,
        images: uploadedImages,
        date: newStory.date || new Date().toISOString().split('T')[0],
      });

      // Reset form
      setNewStory({
        title: '',
        content: '',
        author: '',
        date: new Date().toISOString().split('T')[0],
        tags: [],
      });
      setSelectedImages([]);
      setShowForm(false);

      // Refresh stories
      fetchStories();
    } catch (error) {
      console.error('Error creating story:', error);
      alert('Failed to create story. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (storyId: string) => {
    if (!confirm('Are you sure you want to delete this story?')) return;

    try {
      await deleteFile(storyId);
      fetchStories();
    } catch (error) {
      console.error('Error deleting story:', error);
      alert('Failed to delete story. Please try again.');
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">Loading stories...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold">Memory Wall</h1>
        <button
          onClick={() => setShowForm(!showForm)}
          className="bg-primary text-white px-4 py-2 rounded hover:bg-primary-dark"
        >
          {showForm ? 'Cancel' : 'Share a Memory'}
        </button>
      </div>

      {showForm && (
        <div className="mb-8 bg-white rounded-lg shadow-md p-6">
          <h2 className="text-2xl font-semibold mb-4">Share Your Memory</h2>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-1">Title</label>
              <input
                type="text"
                value={newStory.title}
                onChange={(e) => setNewStory({ ...newStory, title: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Content</label>
              <textarea
                value={newStory.content}
                onChange={(e) => setNewStory({ ...newStory, content: e.target.value })}
                className="w-full p-2 border rounded"
                rows={6}
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Author</label>
              <input
                type="text"
                value={newStory.author}
                onChange={(e) => setNewStory({ ...newStory, author: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Date</label>
              <input
                type="date"
                value={newStory.date}
                onChange={(e) => setNewStory({ ...newStory, date: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Tags (comma-separated)</label>
              <input
                type="text"
                value={newStory.tags.join(', ')}
                onChange={(e) => setNewStory({
                  ...newStory,
                  tags: e.target.value.split(',').map(tag => tag.trim()).filter(Boolean),
                })}
                className="w-full p-2 border rounded"
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Images</label>
              <input
                type="file"
                multiple
                accept="image/*"
                onChange={(e) => setSelectedImages(Array.from(e.target.files || []))}
                className="w-full p-2 border rounded"
              />
            </div>
            <button
              type="submit"
              disabled={loading}
              className="w-full bg-primary text-white p-2 rounded hover:bg-primary-dark disabled:opacity-50"
            >
              {loading ? 'Sharing...' : 'Share Memory'}
            </button>
          </form>
        </div>
      )}

      <div className="grid grid-cols-1 gap-8">
        {stories.map((story) => (
          <article key={story.id} className="bg-white rounded-lg shadow-md p-6">
            <div className="flex justify-between items-start mb-4">
              <h2 className="text-2xl font-semibold">{story.metadata.title}</h2>
              <button
                onClick={() => handleDelete(story.id)}
                className="text-red-600 hover:text-red-800"
              >
                Delete
              </button>
            </div>
            <p className="text-gray-700 mb-6 whitespace-pre-wrap">{story.metadata.content}</p>
            
            {story.metadata.images && story.metadata.images.length > 0 && (
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 mb-6">
                {story.metadata.images.map((image, index) => (
                  <div key={index} className="relative aspect-video">
                    <Image
                      src={image}
                      alt={`Image ${index + 1} from ${story.metadata.title}`}
                      fill
                      className="rounded-lg object-cover"
                    />
                  </div>
                ))}
              </div>
            )}
            
            <div className="flex justify-between items-center">
              <p className="text-sm text-gray-600">
                Shared by {story.metadata.author} on{' '}
                {new Date(story.metadata.date).toLocaleDateString()}
              </p>
              {story.metadata.tags && story.metadata.tags.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {story.metadata.tags.map((tag, index) => (
                    <span
                      key={index}
                      className="bg-gray-100 text-gray-600 px-2 py-1 rounded-full text-sm"
                    >
                      {tag}
                    </span>
                  ))}
                </div>
              )}
            </div>
          </article>
        ))}

        {stories.length === 0 && (
          <div className="text-center text-gray-600">
            No memories shared yet. Be the first to share a memory!
          </div>
        )}
      </div>
    </div>
  );
}


'use client';

import { useState, useEffect } from 'react';
import { listFilesInFolder } from '../lib/googleDrive';
import PhotoUpload from '../components/PhotoUpload';

interface VideoFile {
  id: string;
  name: string;
  webViewLink: string;
  webContentLink: string;
  metadata: {
    title?: string;
    description?: string;
    date?: string;
    tags?: string[];
    location?: string;
  };
}

export default function VideoGallery() {
  const [videos, setVideos] = useState<VideoFile[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchVideos = async () => {
    try {
      const files = await listFilesInFolder(undefined, 'video');
      setVideos(files as VideoFile[]);
    } catch (error) {
      console.error('Error fetching videos:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchVideos();
  }, []);

  const handleUploadComplete = () => {
    fetchVideos();
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">Loading videos...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <PageHeader 
        title="Video Gallery" 
        description="Watch and share our family's precious moments"
      />
      <div className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Upload New Videos</h2>
        <PhotoUpload onUploadComplete={handleUploadComplete} />
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {videos.map((video) => (
          <div key={video.id} className="bg-white rounded-lg shadow-md overflow-hidden">
            <div className="aspect-w-16 aspect-h-9">
              <iframe
                src={`https://drive.google.com/file/d/${video.id}/preview`}
                allow="autoplay"
                className="w-full h-full"
              ></iframe>
            </div>
            <div className="p-4">
              <h3 className="text-lg font-semibold mb-2">{video.metadata.title || video.name}</h3>
              {video.metadata.description && (
                <p className="text-gray-600 mb-2">{video.metadata.description}</p>
              )}
              {video.metadata.date && (
                <p className="text-sm text-gray-500 mb-1">
                  Date: {new Date(video.metadata.date).toLocaleDateString()}
                </p>
              )}
              {video.metadata.location && (
                <p className="text-sm text-gray-500 mb-1">
                  Location: {video.metadata.location}
                </p>
              )}
              {video.metadata.tags && video.metadata.tags.length > 0 && (
                <div className="flex flex-wrap gap-2 mt-2">
                  {video.metadata.tags.map((tag, index) => (
                    <span
                      key={index}
                      className="bg-gray-100 text-gray-600 px-2 py-1 rounded-full text-sm"
                    >
                      {tag}
                    </span>
                  ))}
                </div>
              )}
              <a
                href={video.webContentLink}
                className="inline-block mt-4 text-blue-600 hover:text-blue-800"
                target="_blank"
                rel="noopener noreferrer"
              >
                Download
              </a>
            </div>
          </div>
        ))}
      </div>

      {videos.length === 0 && (
        <div className="text-center text-gray-600 mt-8">
          No videos uploaded yet. Start by uploading your first video!
        </div>
      )}
    </div>
  );
}


'use client'

import { useState, useEffect } from 'react'
import { useParams } from 'next/navigation'
import { listFilesInFolder, uploadFileToDrive, updateFileMetadata, deleteFile } from '../../lib/googleDrive'
import Image from 'next/image'

interface UserProfile {
  name: string
  bio: string
  avatar: string
}

interface UserContribution {
  id: string
  type: 'photo' | 'video' | 'story'
  title: string
  timestamp: number
}

export default function UserProfilePage() {
  const { id } = useParams()
  const [profile, setProfile] = useState<UserProfile | null>(null)
  const [contributions, setContributions] = useState<UserContribution[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchProfile = async () => {
      try {
        const files = await listFilesInFolder(undefined)
        const profileFile = files.find(
          file => file.name === `${id}.profile`
        ) as UserProfile | undefined

        if (profileFile) {
          setProfile(profileFile)
        }
      } catch (error) {
        console.error('Error fetching profile:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchProfile()
  }, [id])

  if (loading) {
    return (
      <div>Loading...</div>
    )
  }

  if (!profile) {
    return (
      <div>Profile not found</div>
    )
  }

  return (
    <div>
      <PageHeader 
        title={profile.name} 
        description="User Profile and Contributions"
      />
      <div className="bg-white rounded-lg shadow-md p-6 mb-8">
        <div className="flex items-center mb-4">
          <Image
            src={profile.avatar}
            alt={profile.name}
            width={100}
            height={100}
            className="rounded-full mr-4"
          />
          <div>
            <h2 className="text-2xl font-bold">{profile.name}</h2>
            <p className="text-gray-600">{profile.bio}</p>
          </div>
        </div>
      </div>
      <div className="bg-white rounded-lg shadow-md p-6">
        <h3 className="text-xl font-bold mb-4">Recent Contributions</h3>
        <ul className="space-y-4">
          {contributions.map((contribution) => (
            <li key={contribution.id} className="border-b pb-2">
              <p className="font-semibold">{contribution.title}</p>
              <p className="text-sm text-gray-600">
                {contribution.type.charAt(0).toUpperCase() + contribution.type.slice(1)}  
                {new Date(contribution.timestamp).toLocaleString()}
              </p>
            </li>
          ))}
        </ul>
      </div>
    </div>
  )
}


'use client'

import { useState, useEffect } from 'react'

export function useAuth() {
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const auth = localStorage.getItem('familyWebsiteAuth')
    if (auth) {
      setIsAuthenticated(true)
    }
  }, [])

  const login = async (password: string) => {
    // In a real application, you would verify this against your backend
    const correctPassword = password

    if (password === correctPassword) {
      setIsAuthenticated(true)
      localStorage.setItem('familyWebsiteAuth', 'true')
      setError(null)
    } else {
      setError('Incorrect password')
    }
  }

  const logout = () => {
    setIsAuthenticated(false)
    localStorage.removeItem('familyWebsiteAuth')
  }

  return { isAuthenticated, login, logout, error }
}



import { google } from 'googleapis';

// Initialize the Google Drive API client
const auth = new google.auth.GoogleAuth({
  credentials: {
    // Your service account credentials will be loaded from environment variables
    client_email: process.env.GOOGLE_CLIENT_EMAIL,
    private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  },
  scopes: [
    'https://www.googleapis.com/auth/drive.file',
    'https://www.googleapis.com/auth/drive.metadata',
  ],
});

// Create a Google Drive client
export const drive = google.drive({ version: 'v3', auth });

// Root folder ID where all content will be stored
export const ROOT_FOLDER_ID = process.env.GOOGLE_DRIVE_FOLDER_ID;

// Mime types for different file categories
export const MIME_TYPES = {
  FOLDER: 'application/vnd.google-apps.folder',
  JPEG: 'image/jpeg',
  PNG: 'image/png',
  MP4: 'video/mp4',
  TEXT: 'text/plain',
} as const;

// File extensions we support
export const SUPPORTED_EXTENSIONS = {
  IMAGES: ['.jpg', '.jpeg', '.png'],
  VIDEOS: ['.mp4', '.mov'],
  DOCUMENTS: ['.txt', '.md'],
} as const;


import { google } from 'googleapis';
import { drive, ROOT_FOLDER_ID, MIME_TYPES } from './googleDriveConfig';

interface FileMetadata {
  [key: string]: any;
}

const auth = new google.auth.GoogleAuth({
  credentials: {
    client_email: process.env.GOOGLE_CLIENT_EMAIL,
    private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  },
  scopes: ['https://www.googleapis.com/auth/drive'],
});

const drive = google.drive({ version: 'v3', auth });

/**
 * Upload a file to Google Drive
 */
export async function uploadFileToDrive(file: File, metadata: FileMetadata) {
  try {
    const buffer = await file.arrayBuffer();
    const media = {
      mimeType: file.type || 'application/octet-stream',
      body: Buffer.from(buffer),
    };

    const fileMetadata = {
      name: file.name,
      parents: [ROOT_FOLDER_ID],
      description: JSON.stringify(metadata),
    };

    const response = await drive.files.create({
      requestBody: fileMetadata,
      media: media,
      fields: 'id, name, webContentLink, webViewLink, description',
    });

    // Make the file publicly accessible
    await drive.permissions.create({
      fileId: response.data.id!,
      requestBody: {
        role: 'reader',
        type: 'anyone',
      },
    });

    // Refresh the file to get the updated links
    const file = await drive.files.get({
      fileId: response.data.id!,
      fields: 'id, name, webContentLink, webViewLink, description',
    });

    return file.data;
  } catch (error) {
    console.error('Error uploading file:', error);
    throw error;
  }
}

/**
 * List files in a specific folder
 */
export async function listFilesInFolder(folderId = ROOT_FOLDER_ID) {
  try {
    const response = await drive.files.list({
      q: `'${folderId}' in parents and trashed = false`,
      fields: 'files(id, name, mimeType, webContentLink, webViewLink, description)',
      pageSize: 1000,
    });

    return response.data.files || [];
  } catch (error) {
    console.error('Error listing files:', error);
    throw error;
  }
}

/**
 * Update file metadata
 */
export async function updateFileMetadata(fileId: string, metadata: FileMetadata) {
  try {
    const response = await drive.files.update({
      fileId,
      requestBody: {
        description: JSON.stringify(metadata),
      },
      fields: 'id, name, webContentLink, webViewLink, description',
    });

    return response.data;
  } catch (error) {
    console.error('Error updating file metadata:', error);
    throw error;
  }
}

/**
 * Delete a file
 */
export async function deleteFile(fileId: string) {
  try {
    await drive.files.delete({
      fileId,
    });
  } catch (error) {
    console.error('Error deleting file:', error);
    throw error;
  }
}

/**
 * Search files by query
 */
export async function searchFiles(query: string) {
  try {
    const response = await drive.files.list({
      q: `fullText contains '${query}' and '${ROOT_FOLDER_ID}' in parents and trashed = false`,
      fields: 'files(id, name, mimeType, webContentLink, webViewLink, description)',
      pageSize: 1000,
    });

    return response.data.files || [];
  } catch (error) {
    console.error('Error searching files:', error);
    throw error;
  }
}

/**
 * Get file by ID
 */
export async function getFile(fileId: string) {
  try {
    const response = await drive.files.get({
      fileId,
      fields: 'id, name, mimeType, webContentLink, webViewLink, description',
    });

    return response.data;
  } catch (error) {
    console.error('Error getting file:', error);
    throw error;
  }
}


'use client';

import { useState, useEffect } from 'react';
import { listFilesInFolder, uploadFileToDrive, deleteFile } from '../lib/googleDrive';
import { PageHeader } from '../components/PageHeader';

interface Event {
  id: string;
  metadata: {
    title: string;
    date: string;
    location?: string;
    description?: string;
    attendees?: string[];
  };
}

export default function Events() {
  const [events, setEvents] = useState<Event[]>([]);
  const [loading, setLoading] = useState(true);
  const [newEvent, setNewEvent] = useState({
    title: '',
    date: '',
    location: '',
    description: '',
    attendees: [] as string[],
  });

  const fetchEvents = async () => {
    try {
      const files = await listFilesInFolder(undefined);
      const eventFiles = files
        .filter(file => file.name.endsWith('.event'))
        .map(file => ({
          id: file.id,
          metadata: JSON.parse(file.description || '{}'),
        }))
        .sort((a, b) => new Date(a.metadata.date).getTime() - new Date(b.metadata.date).getTime()) as Event[];
      setEvents(eventFiles);
    } catch (error) {
      console.error('Error fetching events:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchEvents();
  }, []);

  const handleAddEvent = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      // Create a text file with .event extension to store event data
      const file = new File([''], `${newEvent.title.toLowerCase().replace(/\s+/g, '-')}.event`, {
        type: 'text/plain',
      });

      await uploadFileToDrive(file, newEvent);

      setNewEvent({
        title: '',
        date: '',
        location: '',
        description: '',
        attendees: [],
      });

      fetchEvents();
    } catch (error) {
      console.error('Error adding event:', error);
      alert('Failed to add event. Please try again.');
    }
  };

  const handleDeleteEvent = async (eventId: string) => {
    if (!confirm('Are you sure you want to delete this event?')) return;

    try {
      await deleteFile(eventId);
      fetchEvents();
    } catch (error) {
      console.error('Error deleting event:', error);
      alert('Failed to delete event. Please try again.');
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">Loading events...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <PageHeader
        title="Family Events"
        description="Keep track of our family gatherings and celebrations"
      />

      <div className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Add New Event</h2>
        <form onSubmit={handleAddEvent} className="max-w-md">
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-1">Title</label>
              <input
                type="text"
                value={newEvent.title}
                onChange={(e) => setNewEvent({ ...newEvent, title: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Date</label>
              <input
                type="datetime-local"
                value={newEvent.date}
                onChange={(e) => setNewEvent({ ...newEvent, date: e.target.value })}
                className="w-full p-2 border rounded"
                required
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Location</label>
              <input
                type="text"
                value={newEvent.location}
                onChange={(e) => setNewEvent({ ...newEvent, location: e.target.value })}
                className="w-full p-2 border rounded"
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Description</label>
              <textarea
                value={newEvent.description}
                onChange={(e) => setNewEvent({ ...newEvent, description: e.target.value })}
                className="w-full p-2 border rounded"
                rows={4}
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Attendees (comma-separated)</label>
              <input
                type="text"
                value={newEvent.attendees.join(', ')}
                onChange={(e) => setNewEvent({
                  ...newEvent,
                  attendees: e.target.value.split(',').map(a => a.trim()).filter(Boolean),
                })}
                className="w-full p-2 border rounded"
              />
            </div>
            <button
              type="submit"
              className="w-full bg-primary text-white p-2 rounded hover:bg-primary-dark"
            >
              Add Event
            </button>
          </div>
        </form>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {events.map((event) => (
          <div key={event.id} className="bg-white rounded-lg shadow-md p-6">
            <div className="flex justify-between items-start mb-4">
              <h3 className="text-xl font-semibold">{event.metadata.title}</h3>
              <button
                onClick={() => handleDeleteEvent(event.id)}
                className="text-red-600 hover:text-red-800"
              >
                Delete
              </button>
            </div>
            <p className="text-sm text-gray-600 mb-2">
              Date: {new Date(event.metadata.date).toLocaleString()}
            </p>
            {event.metadata.location && (
              <p className="text-sm text-gray-600 mb-2">
                Location: {event.metadata.location}
              </p>
            )}
            {event.metadata.description && (
              <p className="text-gray-700 mt-2">{event.metadata.description}</p>
            )}
            {event.metadata.attendees && event.metadata.attendees.length > 0 && (
              <div className="mt-4">
                <h4 className="text-sm font-medium mb-2">Attendees:</h4>
                <div className="flex flex-wrap gap-2">
                  {event.metadata.attendees.map((attendee, index) => (
                    <span
                      key={index}
                      className="bg-gray-100 text-gray-600 px-2 py-1 rounded-full text-sm"
                    >
                      {attendee}
                    </span>
                  ))}
                </div>
              </div>
            )}
          </div>
        ))}
      </div>

      {events.length === 0 && (
        <div className="text-center text-gray-600 mt-8">
          No events added yet. Start by adding your first event!
        </div>
      )}
    </div>
  );
}


'use client';

import { useState, useEffect } from 'react';
import { listFilesInFolder } from '../lib/googleDrive';
import PhotoUpload from '../components/PhotoUpload';
import { PageHeader } from '../components/PageHeader';

interface PhotoFile {
  id: string;
  name: string;
  webViewLink: string;
  webContentLink: string;
  metadata: {
    title?: string;
    description?: string;
    date?: string;
    tags?: string[];
    location?: string;
  };
}

export default function PhotoGallery() {
  const [photos, setPhotos] = useState<PhotoFile[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedTag, setSelectedTag] = useState<string>('All');
  const [tags, setTags] = useState<string[]>(['All']);

  const fetchPhotos = async () => {
    try {
      const files = await listFilesInFolder(undefined, 'image');
      setPhotos(files as PhotoFile[]);
      
      // Extract unique tags
      const uniqueTags = new Set<string>();
      files.forEach(file => {
        file.metadata.tags?.forEach(tag => uniqueTags.add(tag));
      });
      setTags(['All', ...Array.from(uniqueTags)]);
    } catch (error) {
      console.error('Error fetching photos:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchPhotos();
  }, []);

  const handleUploadComplete = () => {
    fetchPhotos();
  };

  const filteredPhotos = selectedTag === 'All'
    ? photos
    : photos.filter(photo => photo.metadata.tags?.includes(selectedTag));

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <div className="text-xl">Loading photos...</div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <PageHeader 
        title="Photo Gallery" 
        description="Browse through our cherished family photos"
      />

      <div className="mb-8">
        <h2 className="text-2xl font-semibold mb-4">Upload New Photos</h2>
        <PhotoUpload onUploadComplete={handleUploadComplete} />
      </div>

      <div className="mb-6">
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Filter by Tag:
        </label>
        <select
          value={selectedTag}
          onChange={(e) => setSelectedTag(e.target.value)}
          className="w-full p-2 border rounded focus:outline-none focus:ring-2 focus:ring-primary"
        >
          {tags.map((tag) => (
            <option key={tag} value={tag}>{tag}</option>
          ))}
        </select>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {filteredPhotos.map((photo) => (
          <div key={photo.id} className="bg-white rounded-lg shadow-md overflow-hidden">
            <div className="aspect-w-1 aspect-h-1">
              <img
                src={`https://drive.google.com/uc?id=${photo.id}`}
                alt={photo.metadata.title || photo.name}
                className="object-cover w-full h-full"
              />
            </div>
            <div className="p-4">
              <h3 className="text-lg font-semibold mb-2">{photo.metadata.title || photo.name}</h3>
              {photo.metadata.description && (
                <p className="text-gray-600 mb-2">{photo.metadata.description}</p>
              )}
              {photo.metadata.date && (
                <p className="text-sm text-gray-500 mb-1">
                  Date: {new Date(photo.metadata.date).toLocaleDateString()}
                </p>
              )}
              {photo.metadata.location && (
                <p className="text-sm text-gray-500 mb-1">
                  Location: {photo.metadata.location}
                </p>
              )}
              {photo.metadata.tags && photo.metadata.tags.length > 0 && (
                <div className="flex flex-wrap gap-2 mt-2">
                  {photo.metadata.tags.map((tag, index) => (
                    <span
                      key={index}
                      className="bg-gray-100 text-gray-600 px-2 py-1 rounded-full text-sm"
                    >
                      {tag}
                    </span>
                  ))}
                </div>
              )}
              <a
                href={photo.webContentLink}
                className="inline-block mt-4 text-blue-600 hover:text-blue-800"
                target="_blank"
                rel="noopener noreferrer"
              >
                Download
              </a>
            </div>
          </div>
        ))}
      </div>

      {photos.length === 0 && (
        <div className="text-center text-gray-600 mt-8">
          No photos uploaded yet. Start by uploading your first photo!
        </div>
      )}
    </div>
  );
}


